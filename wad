#!/usr/bin/env bash
#
# wad - Worktree Agent Devcontainers v2.4
# Isolated development environments using git worktrees + docker compose
#
# Configuration:
#   .wad/compose.yml  - Docker compose template (full syntax)
#   .wad/config.yml   - WAD settings (ports, services)
#   .wad/.env         - Environment variables (gitignored)
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

WAD_VERSION="2.4.0"
WAD_DIR=".wad"
WAD_WORKTREES_DIR=".worktrees"
WAD_CONFIG_FILE="config.yml"
WAD_COMPOSE_TEMPLATE="compose.yml"

log_info() { echo -e "${BLUE}ℹ${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warn() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1" >&2; }
log_header() { echo -e "\n${BOLD}${CYAN}$1${NC}\n"; }

die() { log_error "$1"; exit 1; }

find_repo_root() {
    # Works for normal repos and git worktrees (where .git is a file)
    git rev-parse --show-toplevel 2>/dev/null
}

escape_sed_replacement() {
    # Escape replacement text for: sed -e "s|FROM|TO|g"
    # - escape backslash first
    # - escape '&' (means "matched text" in replacement)
    # - escape delimiter '|'
    printf '%s' "$1" | sed -e 's/\\\\/\\\\\\\\/g' -e 's/&/\\\\&/g' -e 's/|/\\\\|/g'
}


check_wad_init() {
    local repo_root
    repo_root=$(find_repo_root) || die "Not in a git repository"
    [[ -d "$repo_root/$WAD_DIR" ]] || die "WAD not initialized. Run 'wad init' first."
    [[ -f "$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE" ]] || die "Missing $WAD_DIR/$WAD_COMPOSE_TEMPLATE"
    echo "$repo_root"
}

# =============================================================================
# Simple YAML helpers (only for config.yml, not compose)
# =============================================================================

yaml_get() {
    # Minimal YAML getter for simple nested maps.
    # Supports dot-path keys like: agent.type
    # Limitations: not a full YAML parser (no complex arrays/objects).
    local file="$1" key="$2" default="$3"
    [[ -f "$file" ]] || { echo "$default"; return; }

    awk -v want="$key" -v dflt="$default" '
        function ltrim(s){ sub(/^[ \t]+/, "", s); return s }
        function rtrim(s){ sub(/[ \t]+$/, "", s); return s }
        function trim(s){ return rtrim(ltrim(s)) }
        function strip_quotes(s){
            s = trim(s)
            if (s ~ /^\".*\"$/) { sub(/^\"/, "", s); sub(/\"$/, "", s) }
            else if (substr(s, 1, 1) == "'" && substr(s, length(s), 1) == "'") { s = substr(s, 2, length(s)-2) }
            return s
        }
        function set_stack(level, k,    i){
            stack[level] = k
            for (i = level + 1; i < 64; i++) delete stack[i]
        }
        function current_path(level,    i, p){
            p = stack[0]
            for (i = 1; i <= level; i++) p = p "." stack[i]
            return p
        }
        BEGIN { found = 0 }
        {
            raw = $0
            sub(/[[:space:]]+#.*$/, "", raw)
            if (raw ~ /^[[:space:]]*$/) next

            indent = match($0, /[^ ]/) - 1
            if (indent < 0) indent = 0
            level = int(indent / 2)

            if (match(raw, /^[[:space:]]*[^:]+:/)) {
                k = raw
                sub(/:.*/, "", k)
                k = trim(k)

                v = raw
                sub(/^[[:space:]]*[^:]+:[[:space:]]*/, "", v)
                v = trim(v)

                set_stack(level, k)
                path = current_path(level)

                if (v != "") {
                    v = strip_quotes(v)
                    if (path == want) { print v; found = 1; exit }
                }
            }
        }
        END { if (!found) print dflt }
    ' "$file"
}

get_config() {
    local repo_root="$1" key="$2" default="$3"
    yaml_get "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE" "$key" "$default"
}

# =============================================================================
# Port Management
# =============================================================================

get_next_env_index() {
    local repo_root="$1" max_index=-1
    local env_files
    env_files=$(ls "$repo_root/$WAD_WORKTREES_DIR"/*/.wad-env 2>/dev/null || true)
    for env_file in $env_files; do
        [[ -f "$env_file" ]] || continue
        local idx=$(grep "^WAD_ENV_INDEX=" "$env_file" 2>/dev/null | cut -d= -f2)
        [[ -n "$idx" && "$idx" -gt "$max_index" ]] && max_index="$idx"
    done
    echo $((max_index + 1))
}

generate_env_file() {
    local env_name="$1" env_index="$2" repo_root="$3"
    local config="$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"
    local increment=$(get_config "$repo_root" "ports.increment" "10")
    
    cat << EOF
# WAD Environment: $env_name
WAD_ENV_NAME=$env_name
WAD_ENV_INDEX=$env_index
EOF
    
    # Calculate ports from config
    awk -v idx="$env_index" -v inc="$increment" '
        /^ports:/ { in_ports = 1; next }
        in_ports && /^[a-zA-Z]/ { exit }
        in_ports && /exposed:/ { in_exposed = 1; next }
        in_exposed && /^[[:space:]]+[A-Z_]+:/ {
            name = $1; gsub(/:/, "", name)
            base = $2; gsub(/[^0-9]/, "", base)
            if (base != "") {
                port = base + (idx * inc)
                print "WAD_PORT_" name "=" port
            }
        }
    ' "$config"
}

load_env_config() {
    local repo_root="$1" env_name="$2"
    local env_file="$repo_root/$WAD_WORKTREES_DIR/$env_name/.wad-env"
    [[ -f "$env_file" ]] && source "$env_file"
}

# =============================================================================
# Compose Generation (simple variable substitution)
# =============================================================================

generate_compose() {
    local repo_root="$1" env_name="$2" worktree_path="$3"
    local template="$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE"
    
    # Load port variables
    source "$worktree_path/.wad-env"
    
    # Build sed substitution commands for all WAD_PORT_* variables
    local sed_args=()
    local repo_root_esc worktree_path_esc env_name_esc
    repo_root_esc=$(escape_sed_replacement "$repo_root")
    worktree_path_esc=$(escape_sed_replacement "$worktree_path")
    env_name_esc=$(escape_sed_replacement "$env_name")

    sed_args+=(-e "s|\\\${repo_root}|${repo_root_esc}|g")
    sed_args+=(-e "s|\\\${worktree_path}|${worktree_path_esc}|g")
    sed_args+=(-e "s|\\\${env_name}|${env_name_esc}|g")
    
    # Add all WAD_PORT_* variables
    while IFS='=' read -r key value; do
        [[ "$key" == WAD_PORT_* ]] && sed_args+=(-e "s|\\\${${key}}|$(escape_sed_replacement "$value")|g")
    done < "$worktree_path/.wad-env"
    
    # Expand ~ to $HOME for paths like ~/Downloads
    sed_args+=(-e "s|~/|${HOME}/|g")
    
    # Add header and process template
    echo "# Generated by wad v${WAD_VERSION} for environment: ${env_name}"
    sed "${sed_args[@]}" "$template"
}



# =============================================================================
# Coding agent helpers (tmux session inside devcontainer)
# =============================================================================

get_agent_config() {
    local repo_root="$1" key="$2" default="$3"
    get_config "$repo_root" "agent.${key}" "$default"
}


is_env_running() {
    local worktree_path="$1" env_name="$2"
    local cid
    cid=$(docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" ps -q devcontainer 2>/dev/null || true)
    [[ -z "$cid" ]] && return 1
    [[ "$(docker inspect -f '{{.State.Running}}' "$cid" 2>/dev/null || echo false)" == "true" ]]
}

require_env_running() {
    local worktree_path="$1" env_name="$2"
    if ! is_env_running "$worktree_path" "$env_name"; then
        log_error "Environment '$env_name' is not running. Start it with: wad start $env_name"
        return 1
    fi
    return 0
}

ensure_tmux_in_container() {
    local worktree_path="$1" env_name="$2"
    # Try to install tmux if missing (Debian-based images)
    # Note: container startup may be installing packages too; avoid apt lock races by waiting
    # for the startup readiness marker.
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc '
      if [ ! -f /tmp/wad-ready ]; then
        for i in $(seq 1 60); do
          [ -f /tmp/wad-ready ] && break
          sleep 1
        done
      fi

      command -v tmux >/dev/null 2>&1 && exit 0
      if command -v apt-get >/dev/null 2>&1; then
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -qq >/dev/null && apt-get install -y -qq tmux >/dev/null && rm -rf /var/lib/apt/lists/*
        exit 0
      fi
      echo "[wad] tmux not found and no supported package manager detected. Install tmux in your devcontainer image." >&2
      exit 1
    '
}

list_service_logs() {
    # Return a de-duplicated list of log files for services.
    # If a service has no `log:` configured, default to /tmp/<service>.log
    local config_file="$1"

    awk '
        function flush() {
            if (svc != "") {
                if (log_path != "") print log_path;
                else print "/tmp/" svc ".log";
            }
        }
        /^services:/ { in_svc = 1; next }

        # End of services section when we hit the next top-level key
        in_svc && /^[a-zA-Z_][a-zA-Z0-9_]*:/ { flush(); exit }

        in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
            flush();
            svc = $1; gsub(/:/, "", svc);
            log_path = "";
            next;
        }
        in_svc && /^[[:space:]]{4}log:/ {
            log_path = $0;
            sub(/.*log:[[:space:]]*/, "", log_path);
            gsub(/[[:space:]]*$/, "", log_path);
            sub(/^"/, "", log_path); sub(/"$/, "", log_path);
            sub(/^\x27/, "", log_path); sub(/\x27$/, "", log_path);
            next;
        }
        END { flush() }
    ' "$config_file" | sed '/^$/d' | sort -u
}

cmd_agent_start() {
    local env_name="$1"
    local prompt="$2"
    [[ -z "$env_name" ]] && die "Usage: wad agent start <env> \"<prompt>\""
    [[ -z "$prompt" ]] && die "Usage: wad agent start <env> \"<prompt>\""

    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    # Do not auto-start; fail gracefully.
    require_env_running "$worktree_path" "$env_name" || exit 1

    local agent_cmd session_name env_file
    agent_cmd="goose"
    session_name=$(get_agent_config "$repo_root" "session_name" "wad-agent")
    env_file=$(get_agent_config "$repo_root" "env_file" ".wad/agent.env")

    local agent_type
    agent_type=$(get_agent_config "$repo_root" "type" "")
    [[ -z "$agent_type" ]] && die "Missing agent.type in .wad/config.yml"
    [[ "$agent_type" != "goose" ]] && die "Unsupported agent.type: $agent_type (only goose supported)"

    ensure_tmux_in_container "$worktree_path" "$env_name"

    local logs
    logs=$(list_service_logs "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE" | paste -sd' ' -)

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T \
      -e WAD_AGENT_SESSION="$session_name" \
      -e WAD_PROMPT="$prompt" \
      -e WAD_AGENT_CMD="$agent_cmd" \
      -e WAD_AGENT_ENV_FILE="$env_file" \
      -e WAD_LOGS="$logs" \
      devcontainer bash -lc '
        set -e
        session="$WAD_AGENT_SESSION"
        agent_target="$session:agent"

        if tmux has-session -t "$session" 2>/dev/null; then
          # Send prompt to the agent window (not whichever window is currently active)
          tmux send-keys -t "$agent_target" -- "$WAD_PROMPT" Enter
          exit 0
        fi

        # Create a named agent window so attach can land here by default.
        tmux new-session -d -s "$session" -n agent -c /workspace bash

        # Create logs window detached so it does not become the default view.
        if [ -n "$WAD_LOGS" ]; then
          tmux new-window -d -t "$session" -n logs "bash -lc \"tail -n 200 -F $WAD_LOGS\""
        fi

        tmux send-keys -t "$agent_target" -- "cd /workspace" Enter
        tmux send-keys -t "$agent_target" -- "[[ -f /workspace/.wad/.env ]] && set -a && source /workspace/.wad/.env && set +a" Enter
        tmux send-keys -t "$agent_target" -- "[[ -f /workspace/$WAD_AGENT_ENV_FILE ]] && set -a && source /workspace/$WAD_AGENT_ENV_FILE && set +a" Enter
        tmux send-keys -t "$agent_target" -- "$WAD_AGENT_CMD" Enter
        tmux send-keys -t "$agent_target" -- "$WAD_PROMPT" Enter
      '

    log_success "Agent session started (tmux: $session_name)"
    log_info "Attach: wad agent attach $env_name"
}

cmd_agent_attach() {
    local env_name="$1"
    [[ -z "$env_name" ]] && die "Usage: wad agent attach <env>"

    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    require_env_running "$worktree_path" "$env_name" || exit 1

    local session_name
    session_name=$(get_agent_config "$repo_root" "session_name" "wad-agent")

    if ! docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc "command -v tmux >/dev/null 2>&1 && tmux has-session -t '$session_name' 2>/dev/null"; then
        die "Agent session is not running. Start it with: wad agent start $env_name \"<prompt>\""
    fi

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec devcontainer tmux attach -t "${session_name}:agent"
}

cmd_agent_stop() {
    local env_name="$1"
    [[ -z "$env_name" ]] && die "Usage: wad agent stop <env>"

    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    require_env_running "$worktree_path" "$env_name" || exit 1

    local session_name
    session_name=$(get_agent_config "$repo_root" "session_name" "wad-agent")

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer tmux kill-session -t "$session_name" 2>/dev/null || true
    log_success "Agent session stopped"
}

cmd_agent_status() {
    local env_name="$1"
    [[ -z "$env_name" ]] && die "Usage: wad agent status <env>"

    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    if ! is_env_running "$worktree_path" "$env_name"; then
        echo "stopped"
        return 0
    fi

    local session_name
    session_name=$(get_agent_config "$repo_root" "session_name" "wad-agent")

    if docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc "command -v tmux >/dev/null 2>&1 && tmux has-session -t '$session_name' 2>/dev/null"; then
        echo "running"
    else
        echo "stopped"
    fi
}

# =============================================================================
# Commands
# =============================================================================

cmd_init() {
    local mode="${1:-}"

    local repo_root
    repo_root=$(find_repo_root) || die "Not in a git repository"

    if [[ -d "$repo_root/$WAD_DIR" ]]; then
        if [[ "$mode" != "--upgrade" && "$mode" != "--force" ]]; then
            log_warn "WAD already initialized"
            log_info "Re-run with: wad init --upgrade"
            return 0
        fi
    fi

    log_header "Initializing WAD"

    # Coding agent selection (for now only: goose)
    # For --upgrade/--force we skip prompting and use goose.
    local agent_type="goose"
    if [[ "$mode" != "--upgrade" && "$mode" != "--force" && -t 0 ]]; then
        read -p "Select coding agent type [goose]: " agent_type
        agent_type=${agent_type:-goose}
    fi
    [[ "$agent_type" != "goose" ]] && die "Unsupported agent type: $agent_type (only goose supported)"

    mkdir -p "$repo_root/$WAD_DIR"
    mkdir -p "$repo_root/$WAD_WORKTREES_DIR"

    # Upgrade behavior: for --upgrade we backup generated templates before overwriting
    local ts="$(date +%Y%m%d%H%M%S)"
    local backup_dir="$repo_root/$WAD_DIR/.backup-$ts"

    backup_if_exists() {
        local f="$1"
        [[ -f "$f" ]] || return 0
        mkdir -p "$backup_dir"
        cp -a "$f" "$backup_dir/"
    }

    if [[ "$mode" == "--upgrade" ]]; then
        backup_if_exists "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"
        backup_if_exists "$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE"
        backup_if_exists "$repo_root/$WAD_DIR/.gitignore"
    fi    # .gitignore for secrets
    if [[ "$mode" == "--upgrade" && -f "$repo_root/$WAD_DIR/.gitignore" ]]; then
        add_ignore() {
            local line="$1"
            grep -qxF "$line" "$repo_root/$WAD_DIR/.gitignore" 2>/dev/null || echo "$line" >> "$repo_root/$WAD_DIR/.gitignore"
        }
        add_ignore '.env'
        add_ignore 'agent.env'
        add_ignore 'goose/'
    else
        cat > "$repo_root/$WAD_DIR/.gitignore" << 'EOF'
.env
agent.env
goose/
EOF
    fi
    
    # Empty env file
    if [[ "$mode" == "--force" || ! -f "$repo_root/$WAD_DIR/.env" ]]; then
        cat > "$repo_root/$WAD_DIR/.env" << 'EOF'
# WAD Environment Variables (gitignored - safe for secrets)
# Sourced by: wad run
# Also available in devcontainer at /workspace/.wad/.env
EOF
    fi

    # Coding agent environment file (gitignored by default; remove from .wad/.gitignore to commit it)
    if [[ "$mode" == "--force" || ! -f "$repo_root/$WAD_DIR/agent.env" ]]; then
        cat > "$repo_root/$WAD_DIR/agent.env" << 'EOF'
# Environment variables for your coding agent (sourced when starting the agent session)
# Examples (uncomment and edit):
# GOOSE_PROVIDER=...
# GOOSE_MODEL=...
EOF
    fi
    
    # Minimal config
    cat > "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE" << 'EOF'
# WAD Configuration
# Docker compose template: .wad/compose.yml
# Environment variables:   .wad/.env (gitignored)

version: 2

ports:
  increment: 10
  exposed:
    APP: 8080

# Services started with `wad run` (inside devcontainer)
services:
  app:
    name: app
    workdir: /workspace
    command: echo "Configure your app command"
    log: /tmp/app.log


# Coding agent (runs inside the devcontainer)
agent:
  # For now, the only supported agent type is `goose`.
  type: goose

  # Extra env vars for the agent (gitignored by default)
  env_file: .wad/agent.env

  # tmux session name used for start/attach/stop
  session_name: wad-agent

  goose:
    # Directory containing goose global config (gitignored by default).
    # This is copied into /root/.config/goose at container start.
    config_dir: .wad/goose
EOF


    # Goose global config (gitignored by default).
    # This will be copied into /root/.config/goose inside the devcontainer at container start.
    mkdir -p "$repo_root/$WAD_DIR/goose"
    if [[ "$mode" == "--force" || ! -f "$repo_root/$WAD_DIR/goose/config.yaml" ]]; then
        cat > "$repo_root/$WAD_DIR/goose/config.yaml" << 'EOF'
GOOSE_PROVIDER:
GOOSE_MODEL:
extensions:
  developer:
    enabled: true
    type: builtin
    name: developer
    description: Code editing and shell access
    display_name: Developer Tools
    timeout: 300
    bundled: true
    available_tools: []
  code_execution:
    enabled: false
    type: platform
    name: code_execution
    description: Execute JavaScript code in a sandboxed environment
    bundled: true
    available_tools: []
  chatrecall:
    enabled: false
    type: platform
    name: chatrecall
    description: Search past conversations and load session summaries for contextual memory
    bundled: true
    available_tools: []
  todo:
    enabled: true
    type: platform
    name: todo
    description: Enable a todo list for goose so it can keep track of what it is doing
    bundled: true
    available_tools: []
  extensionmanager:
    enabled: true
    type: platform
    name: Extension Manager
    description: Enable extension management tools for discovering, enabling, and disabling extensions
    bundled: true
    available_tools: []
  skills:
    enabled: false
    type: platform
    name: skills
    description: Load and use skills from relevant directories
    bundled: true
    available_tools: []
  computercontroller:
    enabled: false
    type: builtin
    name: computercontroller
    description: General computer control tools that don't require you to be a developer or engineer.
    display_name: Computer Controller
    timeout: 300
    bundled: true
    available_tools: []
  autovisualiser:
    enabled: false
    type: builtin
    name: autovisualiser
    description: Data visualisation and UI generation tools
    display_name: Auto Visualiser
    timeout: 300
    bundled: true
    available_tools: []
  memory:
    enabled: true
    type: builtin
    name: memory
    description: Teach goose your preferences as you go.
    display_name: Memory
    timeout: 300
    bundled: true
    available_tools: []
  tutorial:
    enabled: false
    type: builtin
    name: tutorial
    description: Access interactive tutorials and guides
    display_name: Tutorial
    timeout: 300
    bundled: true
    available_tools: []
GOOSE_TELEMETRY_ENABLED: true
SECURITY_PROMPT_ENABLED: false
GOOSE_MODE: auto
GOOSE_DISABLE_KEYRING: ''
GOOSE_CLI_MIN_PRIORITY: 0.2
GOOSE_MAX_TURNS: 1000
EOF
    fi
    
    # Sample compose template
    cat > "$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE" << 'EOF'
# WAD Docker Compose Template
# Variables: ${repo_root}, ${worktree_path}, ${env_name}, ${WAD_PORT_*}
#
# This is a standard docker-compose file with variable substitution.

services:
  devcontainer:
    image: python:3.12-slim
    working_dir: /workspace
    volumes:
      - ${worktree_path}:/workspace
      - ${repo_root}/.wad/.env:/workspace/.wad/.env:ro
      - ${repo_root}/.wad/agent.env:/workspace/.wad/agent.env:ro
      - ${repo_root}/.wad/goose:/workspace/.wad/goose:ro
    ports:
      - "${WAD_PORT_APP}:8080"
    stdin_open: true
    tty: true
    command: >
      bash -lc 'set -e;         if command -v apt-get >/dev/null 2>&1; then           need_pkgs="";           command -v curl >/dev/null 2>&1 || need_pkgs=1;           command -v tmux >/dev/null 2>&1 || need_pkgs=1;           ls /usr/lib/*-linux-gnu/libxcb.so.1 >/dev/null 2>&1 || need_pkgs=1;           if [ -n "$$need_pkgs" ]; then             export DEBIAN_FRONTEND=noninteractive;             apt-get update -qq >/dev/null;             apt-get install -y -qq curl ca-certificates bzip2 tar libxcb1 tmux >/dev/null;             rm -rf /var/lib/apt/lists/*;           fi;         fi;         if ! command -v goose >/dev/null 2>&1; then           arch=$$(uname -m);           case "$$arch" in             x86_64) goose_url="https://github.com/block/goose/releases/latest/download/goose-x86_64-unknown-linux-gnu.tar.bz2" ;;             aarch64|arm64) goose_url="https://github.com/block/goose/releases/latest/download/goose-aarch64-unknown-linux-gnu.tar.bz2" ;;             *) echo "[wad] Unsupported arch for goose: $$arch" >&2; exit 1 ;;           esac;           tmp=$$(mktemp -d);           curl -fsSL "$$goose_url" -o "$$tmp/goose.tar.bz2";           tar -xjf "$$tmp/goose.tar.bz2" -C "$$tmp";           install -m 0755 "$$tmp/goose" /usr/local/bin/goose;           rm -rf "$$tmp";         fi;         if [ -d /workspace/.wad/goose ]; then           mkdir -p /root/.config/goose;           cp -a /workspace/.wad/goose/. /root/.config/goose/ 2>/dev/null || true;         fi;         touch /tmp/wad-ready;         echo "[wad] Ready.";         exec sleep infinity'

networks:
  default:
    name: wad-${env_name}
EOF
    
    log_success "Initialized WAD in $repo_root"
    log_info "Edit $WAD_DIR/$WAD_COMPOSE_TEMPLATE to configure your environment"
    log_info "Edit $WAD_DIR/$WAD_CONFIG_FILE for ports and services"
}

cmd_new() {
    local env_name="$1" base_branch="${2:-}"
    [[ -z "$env_name" ]] && die "Usage: wad new <name> [base-branch]"
    
    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    
    [[ -d "$worktree_path" ]] && die "Environment '$env_name' already exists"
    
    log_header "Creating environment: $env_name"
    
    # Base branch selection precedence:
    # 1) explicit CLI arg
    # 2) config: worktrees.default_base
    # 3) current branch
    # 4) main/master if present
    # 5) HEAD
    if [[ -z "$base_branch" ]]; then
        base_branch=$(get_config "$repo_root" "worktrees.default_base" "")
        [[ -z "$base_branch" ]] && base_branch=$(git -C "$repo_root" symbolic-ref --quiet --short HEAD 2>/dev/null || true)

        if [[ -z "$base_branch" ]]; then
            if git -C "$repo_root" show-ref --verify --quiet refs/heads/main; then
                base_branch="main"
            elif git -C "$repo_root" show-ref --verify --quiet refs/heads/master; then
                base_branch="master"
            else
                base_branch="HEAD"
            fi
        fi
    fi
    
    local env_index=$(get_next_env_index "$repo_root")
    
    log_info "Creating git worktree..."
    git -C "$repo_root" worktree add -b "wad/$env_name" "$worktree_path" "$base_branch"
    
    log_info "Generating environment config..."
    generate_env_file "$env_name" "$env_index" "$repo_root" > "$worktree_path/.wad-env"
    
    log_info "Generating docker-compose..."
    generate_compose "$repo_root" "$env_name" "$worktree_path" > "$worktree_path/.wad-compose.yml"
    
    # Load env for port display
    source "$worktree_path/.wad-env"
    
    log_info "Starting containers..."
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" up -d
    
    log_info "Waiting for devcontainer..."
    local max_wait=120 waited=0
    while [[ $waited -lt $max_wait ]]; do
        if docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer true 2>/dev/null; then
            break
        fi
        sleep 2
        waited=$((waited + 2))
        echo -n "."
    done
    echo ""
    
    [[ $waited -ge $max_wait ]] && log_warn "Devcontainer may not be fully ready"
    
    log_success "Environment '$env_name' created"
    log_info "Ports:"
    (grep "^WAD_PORT_" "$worktree_path/.wad-env" 2>/dev/null || echo "(none)") | sed "s/^/  /"
    log_info "Commands:"
    echo "  wad shell $env_name   # Enter container"
    echo "  wad run $env_name     # Start services"
}

cmd_ls() {
    local repo_root=$(check_wad_init)
    
    echo -e "${BOLD}WAD Environments${NC}"
    echo ""
    
    local found=0
    for env_dir in "$repo_root/$WAD_WORKTREES_DIR"/*/; do
        [[ -d "$env_dir" ]] || continue
        found=1
        
        local env_name=$(basename "$env_dir")
        local env_file="$env_dir/.wad-env"
        local compose_file="$env_dir/.wad-compose.yml"
        
        local ports=""
        if [[ -f "$env_file" ]]; then
            ports=$(grep '^WAD_PORT_' "$env_file" 2>/dev/null | sed 's/^WAD_PORT_//' | tr '\n' ' ' | sed 's/[[:space:]]*$//')
        fi
        
        local status="stopped"
        if [[ -f "$compose_file" ]]; then
            local running=$(docker compose -f "$compose_file" -p "wad-$env_name" ps -q 2>/dev/null | wc -l)
            [[ "$running" -gt 0 ]] && status="${GREEN}running${NC}"
        fi
        
        local branch=$(git -C "$env_dir" branch --show-current 2>/dev/null || echo "?")
        
        printf "  ${BOLD}%-20s${NC} %s  (%s)\n" "$env_name" "${ports:+ports:$ports }$status" "$branch"
    done
    
    [[ $found -eq 0 ]] && echo "  No environments found. Create one with: wad new <name>"
}

cmd_shell() {
    local env_name="$1"
    [[ -z "$env_name" ]] && die "Usage: wad shell <name>"
    
    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"
    
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec devcontainer bash
}

cmd_run() {
    local env_name="$1"
    [[ -z "$env_name" ]] && die "Usage: wad run <name>"
    
    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"
    
    local config="$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"
    
    # Build command to source env and start services
    local cmd="cd /workspace && "
    cmd+="[[ -f .wad/.env ]] && set -a && source .wad/.env && set +a; "
    
    # Parse services from config
    local services=$(awk '
        /^services:/ { in_svc = 1; next }
        in_svc && /^[a-zA-Z]/ && !/^[[:space:]]/ { exit }
        in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
            name = $1; gsub(/:/, "", name)
            print name
        }
    ' "$config")
    
    for svc in $services; do
        local svc_workdir=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ { 
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /workdir:/ { 
                gsub(/.*workdir:[[:space:]]*/, ""); 
                gsub(/[[:space:]]*$/, "");
                print; exit 
            }
        ' "$config")
        
        local svc_cmd=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ { 
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /command:/ { 
                gsub(/.*command:[[:space:]]*/, ""); 
                gsub(/[[:space:]]*$/, "");
                print; exit 
            }
        ' "$config")
        
        local svc_log=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ { 
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /log:/ { 
                gsub(/.*log:[[:space:]]*/, ""); 
                gsub(/[[:space:]]*$/, "");
                print; exit 
            }
        ' "$config")
        
        local svc_env=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ { 
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
                in_env = 0
            }
            in_current && /^[[:space:]]{4}env:/ { in_env = 1; next }
            in_current && in_env && /^[[:space:]]{6}[A-Z_]+:/ {
                key = $1; gsub(/:/, "", key)
                val = $0; gsub(/.*:[[:space:]]*/, "", val)
                gsub(/^["'"'"']|["'"'"']$/, "", val)
                print "export " key "=\"" val "\"; "
            }
            in_current && in_env && /^[[:space:]]{4}[a-z]/ { in_env = 0 }
        ' "$config")
        
        if [[ -n "$svc_cmd" ]]; then
            log_info "Starting $svc..."
            [[ -z "$svc_log" ]] && svc_log="/tmp/${svc}.log"
            local log_redirect=" >> $svc_log 2>&1"
            cmd+="$svc_env cd ${svc_workdir:-/workspace} && $svc_cmd$log_redirect & "
        fi
    done
    
    cmd+="echo 'Services started'; sleep infinity"
    
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -d devcontainer bash -c "$cmd"
    
    log_success "Services started"
    log_info "View logs: wad logs $env_name <service>"
}


cmd_logs() {
    local env_name="$1" service="${2:-}"
    [[ -z "$env_name" ]] && die "Usage: wad logs <name> [service]"
    
    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"
    
    if [[ -z "$service" ]]; then
        docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" logs -f
    else
        local config="$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"
        local log_file=$(awk -v svc="$service" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ { 
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /log:/ { 
                gsub(/.*log:[[:space:]]*/, ""); 
                gsub(/[[:space:]]*$/, "");
                print; exit 
            }
        ' "$config")
        
        if [[ -z "$log_file" ]]; then
            log_file="/tmp/${service}.log"
        fi
        docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec devcontainer tail -f "$log_file"
    fi
}

cmd_start() {
    local env_name="$1"
    [[ -z "$env_name" ]] && die "Usage: wad start <name>"
    
    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"
    
    load_env_config "$repo_root" "$env_name"
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" up -d
    log_success "Started"
}

cmd_stop() {
    local env_name="$1"
    [[ -z "$env_name" ]] && die "Usage: wad stop <name>"
    
    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"
    
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" stop
    log_success "Stopped"
}

cmd_rm() {
    local env_name="$1" force="${2:-}"
    [[ -z "$env_name" ]] && die "Usage: wad rm <name> [--force]"
    
    local repo_root=$(check_wad_init)
    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"
    
    if [[ "$force" != "--force" ]]; then
        read -p "Remove '$env_name'? [y/N] " -n 1 -r; echo
        [[ $REPLY =~ ^[Yy]$ ]] || exit 0
    fi
    
    log_info "Removing containers..."
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" down -v 2>/dev/null || true

    log_info "Removing worktree..."
    if ! git -C "$repo_root" worktree remove "$worktree_path" --force 2>/dev/null; then
        log_warn "Worktree removal failed; deleting uid=0 (root-owned) paths and retrying..."
        # Some containers create files as uid 0 on bind-mounted volumes.
        # That can prevent deletion on the host. Remove only uid-0 paths.
        docker run --rm -v "$worktree_path:/workspace" alpine:3.19 sh -c '
          set -e
          find /workspace -mindepth 1 -uid 0 -exec rm -rf -- {} + 2>/dev/null || true
        ' || true

        git -C "$repo_root" worktree remove "$worktree_path" --force 2>/dev/null || rm -rf "$worktree_path"
    fi

    git -C "$repo_root" branch -D "wad/$env_name" 2>/dev/null || true
    
    log_success "Removed"
}

cmd_help() {
    cat << EOF
${BOLD}wad${NC} v$WAD_VERSION - Worktree Agent Devcontainers

${BOLD}COMMANDS${NC}
  init              Initialize wad in current repo
  new <name>        Create new environment
  ls                List environments
  
  start <name>      Start containers
  stop <name>       Stop containers  
  rm <name>         Remove environment
  
  shell <name>      Enter container shell
  run <name>        Start services (from config.yml)
  agent start <env> "<prompt>"  Start agent session and send initial prompt (requires env running)
  agent attach <env>             Attach (tmux) to running agent session
  agent stop <env>               Stop agent session
  agent status <env>             Print running/stopped
  logs <name> [svc] View logs

${BOLD}CONFIGURATION${NC}
  .wad/compose.yml      Docker compose template (full syntax)
  .wad/config.yml       WAD settings (ports, services)
  .wad/.env             Environment variables (gitignored)

${BOLD}TEMPLATE VARIABLES${NC}
  \${repo_root}         Path to main repository
  \${worktree_path}     Path to worktree directory  
  \${env_name}          Environment name
  \${WAD_PORT_*}        Calculated ports from config.yml

${BOLD}EXAMPLE${NC}
  wad init
  # Edit .wad/compose.yml (your docker-compose template)
  # Edit .wad/config.yml (ports, services)
  wad new feature-x
  wad run feature-x
EOF
}

# Main
case "${1:-help}" in
    init)    cmd_init "${@:2}" ;;
    new)     cmd_new "${@:2}" ;;
    ls)      cmd_ls ;;
    start)   cmd_start "${@:2}" ;;
    stop)    cmd_stop "${@:2}" ;;
    rm)      cmd_rm "${@:2}" ;;
    shell)   cmd_shell "${@:2}" ;;
    run)     cmd_run "${@:2}" ;;
    logs)    cmd_logs "${@:2}" ;;
    agent)
        subcmd="${2:-help}"
        env_name="${3:-}"
        shift 3 || true
        prompt="$*"
        case "$subcmd" in
            start)  cmd_agent_start "$env_name" "$prompt" ;;
            attach) cmd_agent_attach "$env_name" ;;
            stop)   cmd_agent_stop "$env_name" ;;
            status) cmd_agent_status "$env_name" ;;
            *) die "Usage: wad agent {start|attach|stop|status} <env> [\"prompt\"]" ;;
        esac
        ;;
    help|--help|-h) cmd_help ;;
    version|--version|-v) echo "wad $WAD_VERSION" ;;
    *)       die "Unknown: $1" ;;
esac
