#!/usr/bin/env bash
#
# wad - Worktree Agent Devcontainers v3
# Isolated development environments using git worktrees + docker compose
#
# Primary UX:
#   wad init
#   # edit .wad/compose.yml and .wad/config.yml
#   wad new <env> [prompt...]   # creates env, starts containers+services, optionally starts goose
#   wad agent <env> <prompt...> # start goose for an existing env
#   wad attach <env>            # attach to tmux session in the devcontainer to watch progress
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

WAD_VERSION="3.0.0"
WAD_DIR=".wad"
WAD_WORKTREES_DIR=".worktrees"
WAD_CONFIG_FILE="config.yml"
WAD_COMPOSE_TEMPLATE="compose.yml"

log_info() { echo -e "${BLUE}ℹ${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warn() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1" >&2; }
log_header() { echo -e "\n${BOLD}${CYAN}$1${NC}\n"; }

die() { log_error "$1"; exit 1; }

# Run a command with a timeout if `timeout(1)` is available.
# Usage: run_with_timeout 5s <cmd> [args...]
run_with_timeout() {
    local dur="$1"; shift || true
    if command -v timeout >/dev/null 2>&1; then
        timeout "$dur" "$@"
    else
        "$@"
    fi
}

find_repo_root() {
    # Works for normal repos and git worktrees (where .git is a file)
    git rev-parse --show-toplevel 2>/dev/null
}

escape_sed_replacement() {
    # Escape replacement text for: sed -e "s|FROM|TO|g"
    # - escape backslash first
    # - escape '&' (means "matched text" in replacement)
    # - escape delimiter '|'
    printf '%s' "$1" | sed -e 's/\\\\/\\\\\\\\/g' -e 's/&/\\\\&/g' -e 's/|/\\\\|/g'
}

check_wad_init() {
    local repo_root
    repo_root=$(find_repo_root) || die "Not in a git repository"
    [[ -d "$repo_root/$WAD_DIR" ]] || die "WAD not initialized. Run 'wad init' first."
    [[ -f "$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE" ]] || die "Missing $WAD_DIR/$WAD_COMPOSE_TEMPLATE"
    echo "$repo_root"
}

slugify() {
    # Convert arbitrary text to a safe kebab-case slug suitable for:
    # - directory names
    # - compose project suffixes
    # - git branch suffixes
    local s="$*"
    s=$(printf '%s' "$s" | tr '[:upper:]' '[:lower:]')
    # Replace any non-alnum with '-'
    s=$(printf '%s' "$s" | sed -E 's/[^a-z0-9]+/-/g')
    # Collapse repeated '-', trim leading/trailing '-'
    s=$(printf '%s' "$s" | sed -E 's/-+/-/g; s/^-+//; s/-+$//')
    # Limit length (avoid absurdly long branch/worktree names)
    s=$(printf '%s' "$s" | cut -c1-48)
    [[ -z "$s" ]] && s="env"
    printf '%s' "$s"
}

# =============================================================================
# Worktree-local git excludes
# =============================================================================

git_exclude_file_for_repo() {
    # Return the absolute path to the repo's exclude file (info/exclude).
    # Works for:
    # - normal repos
    # - git worktrees (where .git is a file pointing at a gitdir)
    local repo_path="$1"

    local p
    p=$(git -C "$repo_path" rev-parse --git-path info/exclude 2>/dev/null) || return 1

    # rev-parse may return a relative path (e.g. .git/info/exclude)
    if [[ "$p" != /* ]]; then
        p="$repo_path/$p"
    fi

    echo "$p"
}

add_to_worktree_exclude() {
    # Add an ignore entry to the worktree's .git/info/exclude (idempotent).
    local worktree_path="$1" line="$2"

    local exclude_file
    exclude_file=$(git_exclude_file_for_repo "$worktree_path") || return 0

    mkdir -p "$(dirname "$exclude_file")"
    touch "$exclude_file"

    grep -qxF "$line" "$exclude_file" 2>/dev/null || echo "$line" >> "$exclude_file"
}

ensure_wad_worktree_files_ignored() {
    # Ensure wad-generated files in a worktree don't show up as untracked.
    local worktree_path="$1"

    # These files are created by `wad new` inside the worktree.
    add_to_worktree_exclude "$worktree_path" ".wad-env"
    add_to_worktree_exclude "$worktree_path" ".wad-compose.yml"
}

# =============================================================================
# Simple YAML helpers (only for config.yml, not compose)
# =============================================================================

yaml_get() {
    # Minimal YAML getter for simple nested maps.
    # Supports dot-path keys like: agent.type
    # Limitations: not a full YAML parser (no complex arrays/objects).
    local file="$1" key="$2" default="$3"
    [[ -f "$file" ]] || { echo "$default"; return; }

    awk -v want="$key" -v dflt="$default" '
        function ltrim(s){ sub(/^[ \t]+/, "", s); return s }
        function rtrim(s){ sub(/[ \t]+$/, "", s); return s }
        function trim(s){ return rtrim(ltrim(s)) }
        function strip_quotes(s){
            s = trim(s)
            if (s ~ /^\".*\"$/) { sub(/^\"/, "", s); sub(/\"$/, "", s) }
            else if (substr(s, 1, 1) == "\x27" && substr(s, length(s), 1) == "\x27") { s = substr(s, 2, length(s)-2) }
            return s
        }
        function set_stack(level, k,    i){
            stack[level] = k
            for (i = level + 1; i < 64; i++) delete stack[i]
        }
        function current_path(level,    i, p){
            p = stack[0]
            for (i = 1; i <= level; i++) p = p "." stack[i]
            return p
        }
        BEGIN { found = 0 }
        {
            raw = $0
            sub(/[[:space:]]+#.*$/, "", raw)
            if (raw ~ /^[[:space:]]*$/) next

            indent = match($0, /[^ ]/) - 1
            if (indent < 0) indent = 0
            level = int(indent / 2)

            if (match(raw, /^[[:space:]]*[^:]+:/)) {
                k = raw
                sub(/:.*/, "", k)
                k = trim(k)

                v = raw
                sub(/^[[:space:]]*[^:]+:[[:space:]]*/, "", v)
                v = trim(v)

                set_stack(level, k)
                path = current_path(level)

                if (v != "") {
                    v = strip_quotes(v)
                    if (path == want) { print v; found = 1; exit }
                }
            }
        }
        END { if (!found) print dflt }
    ' "$file"
}

get_config() {
    local repo_root="$1" key="$2" default="$3"
    yaml_get "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE" "$key" "$default"
}

# =============================================================================
# Port Management
# =============================================================================

get_next_env_index() {
    local repo_root="$1" max_index=-1
    local env_files
    env_files=$(ls "$repo_root/$WAD_WORKTREES_DIR"/*/.wad-env 2>/dev/null || true)
    for env_file in $env_files; do
        [[ -f "$env_file" ]] || continue
        local idx
        idx=$(grep "^WAD_ENV_INDEX=" "$env_file" 2>/dev/null | cut -d= -f2)
        [[ -n "$idx" && "$idx" -gt "$max_index" ]] && max_index="$idx"
    done
    echo $((max_index + 1))
}

generate_env_file() {
    local env_name="$1" env_index="$2" repo_root="$3"
    local config="$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"
    local increment
    increment=$(get_config "$repo_root" "ports.increment" "10")

    cat << EOF
# WAD Environment: $env_name
WAD_ENV_NAME=$env_name
WAD_ENV_INDEX=$env_index
EOF

    # Calculate ports from config
    awk -v idx="$env_index" -v inc="$increment" '
        /^ports:/ { in_ports = 1; next }
        in_ports && /^[a-zA-Z]/ { exit }
        in_ports && /exposed:/ { in_exposed = 1; next }
        in_exposed && /^[[:space:]]+[A-Z_]+:/ {
            name = $1; gsub(/:/, "", name)
            base = $2; gsub(/[^0-9]/, "", base)
            if (base != "") {
                port = base + (idx * inc)
                print "WAD_PORT_" name "=" port
            }
        }
    ' "$config"
}

load_env_config() {
    local repo_root="$1" env_name="$2"
    local env_file="$repo_root/$WAD_WORKTREES_DIR/$env_name/.wad-env"
    [[ -f "$env_file" ]] && source "$env_file"
}

# =============================================================================
# Compose Generation (simple variable substitution)
# =============================================================================

generate_compose() {
    local repo_root="$1" env_name="$2" worktree_path="$3"
    local template="$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE"

    # Load port variables
    source "$worktree_path/.wad-env"

    # Build sed substitution commands for all WAD_PORT_* variables
    local sed_args=()
    local repo_root_esc worktree_path_esc env_name_esc
    repo_root_esc=$(escape_sed_replacement "$repo_root")
    worktree_path_esc=$(escape_sed_replacement "$worktree_path")
    env_name_esc=$(escape_sed_replacement "$env_name")

    sed_args+=(-e "s|\\\${repo_root}|${repo_root_esc}|g")
    sed_args+=(-e "s|\\\${worktree_path}|${worktree_path_esc}|g")
    sed_args+=(-e "s|\\\${env_name}|${env_name_esc}|g")

    # Add all WAD_PORT_* variables
    while IFS='=' read -r key value; do
        [[ "$key" == WAD_PORT_* ]] && sed_args+=(-e "s|\\\${${key}}|$(escape_sed_replacement "$value")|g")
    done < "$worktree_path/.wad-env"

    # Expand ~ to $HOME for paths like ~/Downloads
    sed_args+=(-e "s|~/|${HOME}/|g")

    # Add header and process template
    echo "# Generated by wad v${WAD_VERSION} for environment: ${env_name}"
    sed "${sed_args[@]}" "$template"
}

# =============================================================================
# Devcontainer + agent (tmux) helpers
# =============================================================================

wait_for_devcontainer_ready() {
    local worktree_path="$1" env_name="$2" max_wait="${3:-180}"

    log_info "Waiting for devcontainer readiness marker (/tmp/wad-ready)..."

    local start now
    start=$(date +%s)
    while true; do
        if docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc 'test -f /tmp/wad-ready' >/dev/null 2>&1; then
            log_success "Devcontainer ready"
            return 0
        fi

        now=$(date +%s)
        if (( now - start >= max_wait )); then
            log_warn "Timed out waiting for devcontainer readiness after ${max_wait}s"
            return 1
        fi
        sleep 2
    done
}

get_agent_config() {
    local repo_root="$1" key="$2" default="$3"
    get_config "$repo_root" "agent.${key}" "$default"
}

is_env_running() {
    local worktree_path="$1" env_name="$2"
    local cid
    cid=$(docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" ps -q devcontainer 2>/dev/null || true)
    [[ -z "$cid" ]] && return 1
    [[ "$(docker inspect -f '{{.State.Running}}' "$cid" 2>/dev/null || echo false)" == "true" ]]
}

require_env_running() {
    local worktree_path="$1" env_name="$2"
    if ! is_env_running "$worktree_path" "$env_name"; then
        log_error "Environment '$env_name' is not running. Start it with: wad start $env_name"
        return 1
    fi
    return 0
}

ensure_tmux_in_container() {
    local worktree_path="$1" env_name="$2"
    # Try to install tmux if missing (Debian-based images)
    # Note: container startup may be installing packages too; avoid apt lock races by waiting
    # for the startup readiness marker.
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc '
      if [ ! -f /tmp/wad-ready ]; then
        for i in $(seq 1 60); do
          [ -f /tmp/wad-ready ] && break
          sleep 1
        done
      fi

      command -v tmux >/dev/null 2>&1 && exit 0
      if command -v apt-get >/dev/null 2>&1; then
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -qq >/dev/null && apt-get install -y -qq tmux >/dev/null && rm -rf /var/lib/apt/lists/*
        exit 0
      fi
      echo "[wad] tmux not found and no supported package manager detected. Install tmux in your devcontainer image." >&2
      exit 1
    '
}

list_service_logs() {
    # Return a de-duplicated list of log files for services.
    # If a service has no `log:` configured, default to /tmp/<service>.log
    local config_file="$1"

    awk '
        function flush() {
            if (svc != "") {
                if (log_path != "") print log_path;
                else print "/tmp/" svc ".log";
            }
        }
        /^services:/ { in_svc = 1; next }

        # End of services section when we hit the next top-level key
        in_svc && /^[a-zA-Z_][a-zA-Z0-9_]*:/ { flush(); exit }

        in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
            flush();
            svc = $1; gsub(/:/, "", svc);
            log_path = "";
            next;
        }
        in_svc && /^[[:space:]]{4}log:/ {
            log_path = $0;
            sub(/.*log:[[:space:]]*/, "", log_path);
            gsub(/[[:space:]]*$/, "", log_path);
            sub(/^"/, "", log_path); sub(/"$/, "", log_path);
            sub(/^\x27/, "", log_path); sub(/\x27$/, "", log_path);
            next;
        }
        END { flush() }
    ' "$config_file" | sed '/^$/d' | sort -u
}

start_goose_task() {
    local repo_root="$1" worktree_path="$2" env_name="$3" prompt="$4"

    local session_name env_file
    session_name=$(get_agent_config "$repo_root" "session_name" "wad-agent")
    env_file=$(get_agent_config "$repo_root" "env_file" ".wad/agent.env")

    ensure_tmux_in_container "$worktree_path" "$env_name"

    local logs
    logs=$(list_service_logs "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE" | paste -sd' ' -)

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T \
      -e WAD_AGENT_SESSION="$session_name" \
      -e WAD_AGENT_ENV_FILE="$env_file" \
      -e WAD_LOGS="$logs" \
      -e WAD_PROMPT="$prompt" \
      devcontainer bash -lc '
        set -e

        session="$WAD_AGENT_SESSION"
        agent_target="$session:agent"

        # Persist prompt to file so tmux shells can read it (they won\x27t inherit docker exec env).
        printf "%s" "$WAD_PROMPT" > /tmp/wad-prompt

        if ! tmux has-session -t "$session" 2>/dev/null; then
          tmux new-session -d -s "$session" -n agent -c /workspace bash

          # A dedicated logs window (goose + service logs)
          tmux new-window -d -t "$session" -n logs "bash -lc \"touch /tmp/goose.log; tail -n 200 -F /tmp/goose.log $WAD_LOGS\""
        fi

        tmux send-keys -t "$agent_target" -- "cd /workspace" Enter
        tmux send-keys -t "$agent_target" -- "[[ -f /workspace/.wad/.env ]] && set -a && source /workspace/.wad/.env && set +a" Enter
        tmux send-keys -t "$agent_target" -- "[[ -f /workspace/$WAD_AGENT_ENV_FILE ]] && set -a && source /workspace/$WAD_AGENT_ENV_FILE && set +a" Enter

        # Reset completion markers for this run.
        tmux send-keys -t "$agent_target" -- "rm -f /tmp/wad-goose-done /tmp/wad-goose-exit /tmp/wad-goose-out.log /tmp/wad-goose-result.json" Enter

        # Run goose via the WAD unattended task recipe and log output.
        # Pass the prompt via a file param so we do not fight shell quoting.
        tmux send-keys -t "$agent_target" -- "(goose run --no-session --recipe /workspace/.wad/goose/recipes/wad_task.yaml --params task=/tmp/wad-prompt 2>&1 | tee /tmp/wad-goose-out.log | tee -a /tmp/goose.log; ec=\${PIPESTATUS[0]}; echo \"\$ec\" > /tmp/wad-goose-exit; touch /tmp/wad-goose-done)" Enter
      '

    log_success "Goose started in background (tmux session: $session_name)"
}

# =============================================================================
# Commands
# =============================================================================

cmd_init() {
    local mode="${1:-}"

    local repo_root
    repo_root=$(find_repo_root) || die "Not in a git repository"

    if [[ -d "$repo_root/$WAD_DIR" ]]; then
        if [[ "$mode" != "--upgrade" && "$mode" != "--force" ]]; then
            log_warn "WAD already initialized"
            log_info "Re-run with: wad init --upgrade"
            return 0
        fi
    fi

    log_header "Initializing WAD"

    mkdir -p "$repo_root/$WAD_DIR"
    mkdir -p "$repo_root/$WAD_WORKTREES_DIR"

    # Upgrade behavior: for --upgrade we backup generated templates before overwriting
    local ts
    ts="$(date +%Y%m%d%H%M%S)"
    local backup_dir="$repo_root/$WAD_DIR/.backup-$ts"

    backup_if_exists() {
        local f="$1"
        [[ -f "$f" ]] || return 0
        mkdir -p "$backup_dir"
        cp -a "$f" "$backup_dir/"
    }

    if [[ "$mode" == "--upgrade" ]]; then
        backup_if_exists "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"
        backup_if_exists "$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE"
        backup_if_exists "$repo_root/$WAD_DIR/.gitignore"
    fi

    # .gitignore for secrets
    if [[ "$mode" == "--upgrade" && -f "$repo_root/$WAD_DIR/.gitignore" ]]; then
        add_ignore() {
            local line="$1"
            grep -qxF "$line" "$repo_root/$WAD_DIR/.gitignore" 2>/dev/null || echo "$line" >> "$repo_root/$WAD_DIR/.gitignore"
        }
        add_ignore '.env'
        add_ignore 'agent.env'
        add_ignore 'goose/'
    else
        cat > "$repo_root/$WAD_DIR/.gitignore" << 'EOF'
.env
agent.env
goose/
EOF
    fi

    # Empty env file (gitignored by default). Even with --force, do NOT clobber.
    if [[ ! -f "$repo_root/$WAD_DIR/.env" ]]; then
        cat > "$repo_root/$WAD_DIR/.env" << 'EOF'
# WAD Environment Variables (gitignored - safe for secrets)
# Sourced by: wad run
# Also available in devcontainer at /workspace/.wad/.env
EOF
    fi

    # Agent environment file (gitignored by default). Even with --force, do NOT clobber.
    if [[ ! -f "$repo_root/$WAD_DIR/agent.env" ]]; then
        cat > "$repo_root/$WAD_DIR/agent.env" << 'EOF'
# Environment variables for goose (sourced inside the devcontainer before running goose)
# Examples (uncomment and edit):
# GOOSE_PROVIDER=...
# GOOSE_MODEL=...
EOF
    fi

    # Minimal config
    cat > "$repo_root/$WAD_DIR/$WAD_CONFIG_FILE" << 'EOF'
# WAD Configuration
# Docker compose template: .wad/compose.yml
# Environment variables:   .wad/.env (gitignored)

version: 3

ports:
  increment: 10
  exposed:
    APP: 8080

# Services started automatically by `wad new` (and manually by `wad run`)
services:
  app:
    name: app
    workdir: /workspace
    command: echo "Configure your app command"
    log: /tmp/app.log

# Goose settings (runs inside the devcontainer)
agent:
  type: goose

  # Extra env vars for goose (gitignored by default)
  env_file: .wad/agent.env

  # tmux session name used for attach
  session_name: wad-agent

  goose:
    # Directory containing goose global config (gitignored by default).
    # This is copied into /root/.config/goose at container start.
    config_dir: .wad/goose
EOF

    # Goose global config (gitignored by default).
    mkdir -p "$repo_root/$WAD_DIR/goose"
    # Even with --force, do NOT clobber. This is where provider/model may live.
    if [[ ! -f "$repo_root/$WAD_DIR/goose/config.yaml" ]]; then
        cat > "$repo_root/$WAD_DIR/goose/config.yaml" << 'EOF'
GOOSE_PROVIDER:
GOOSE_MODEL:
extensions:
  developer:
    enabled: true
    type: builtin
    name: developer
    description: Code editing and shell access
    display_name: Developer Tools
    timeout: 300
    bundled: true
    available_tools: []
  todo:
    enabled: true
    type: platform
    name: todo
    description: Enable a todo list for goose so it can keep track of what it is doing
    bundled: true
    available_tools: []
  extensionmanager:
    enabled: true
    type: platform
    name: Extension Manager
    description: Enable extension management tools for discovering, enabling, and disabling extensions
    bundled: true
    available_tools: []
  memory:
    enabled: true
    type: builtin
    name: memory
    description: Teach goose your preferences as you go.
    display_name: Memory
    timeout: 300
    bundled: true
    available_tools: []
GOOSE_TELEMETRY_ENABLED: true
SECURITY_PROMPT_ENABLED: false
GOOSE_MODE: auto
GOOSE_DISABLE_KEYRING: ''
GOOSE_CLI_MIN_PRIORITY: 0.2
GOOSE_MAX_TURNS: 1000
EOF
    fi


    # WAD unattended task recipe (used by wad new)
    # Stored under the goose config dir so it is available in-container at:
    #   /workspace/.wad/goose/recipes/wad_task.yaml
    mkdir -p "$repo_root/$WAD_DIR/goose/recipes"


    # Recipes are user-tweakable; do not clobber even with --force.
    if [[ ! -f "$repo_root/$WAD_DIR/goose/recipes/wad_task.yaml" ]]; then
        cat > "$repo_root/$WAD_DIR/goose/recipes/wad_task.yaml" << 'EOF'
version: "1.0.0"
title: "WAD Unattended Task"
description: "Run a single unattended task in a repo. No human interaction expected."

parameters:
  - key: task
    input_type: file
    requirement: required
    description: "Path to a file containing the user-provided task prompt"

prompt: |
  You are running as an UNATTENDED coding agent inside a devcontainer.
  You will NOT receive additional user messages in the happy path.

  Rules:
  - Do NOT ask the user questions.
  - Do NOT wait for user input.
  - If information is missing, make a reasonable assumption and record it.
  - If you are blocked (e.g., missing credentials, unclear requirements, failing setup you cannot fix),
    stop and produce a BLOCKED result with what you need.
  - Prefer making small, safe changes; avoid destructive actions.
  - When possible, run quick checks (format/lint/test) to validate changes.
  - If you change files, keep edits minimal and coherent.

  Execution style:
  1) Restate the task in your own words.
  2) Make a short plan.
  3) Execute the plan.
  4) Validate (tests/build/etc) if feasible.
  5) Produce a final structured result (see response schema).

  Task:
  {{ task }}

response:
  json_schema:
    type: object
    additionalProperties: false
    properties:
      status:
        type: string
        description: "Overall result status"
        enum: ["completed", "blocked"]
      summary:
        type: string
        description: "Short human-readable summary of what happened"
      assumptions:
        type: array
        items: { type: string }
        description: "Assumptions you made due to missing context"
      changes_made:
        type: array
        items: { type: string }
        description: "High-level description of changes"
      files_modified:
        type: array
        items: { type: string }
        description: "Paths of files modified/created"
      commands_run:
        type: array
        items: { type: string }
        description: "Commands executed (tests, formatting, etc.)"
      validation:
        type: string
        description: "What validation was run and what the outcome was"
      blocking_reasons:
        type: array
        items: { type: string }
        description: "Concrete reasons why work could not be completed"
      blocking_questions:
        type: array
        items: { type: string }
        description: "Questions that must be answered to proceed (only if blocked)"
      next_steps:
        type: array
        items: { type: string }
        description: "Suggested next steps for a human or a follow-up agent run"
    required:
      - status
      - summary
      - assumptions
      - changes_made
      - files_modified
      - commands_run
      - validation
      - blocking_reasons
      - blocking_questions
      - next_steps
EOF
    fi


    # Sample compose template
    cat > "$repo_root/$WAD_DIR/$WAD_COMPOSE_TEMPLATE" << 'EOF'
# WAD Docker Compose Template
# Variables: ${repo_root}, ${worktree_path}, ${env_name}, ${WAD_PORT_*}
#
# This is a standard docker-compose file with variable substitution.

services:
  devcontainer:
    image: python:3.12-slim
    working_dir: /workspace
    volumes:
      - ${worktree_path}:/workspace
      - ${repo_root}/.wad/.env:/workspace/.wad/.env:ro
      - ${repo_root}/.wad/agent.env:/workspace/.wad/agent.env:ro
      - ${repo_root}/.wad/goose:/workspace/.wad/goose:ro
    ports:
      - "${WAD_PORT_APP}:8080"
    stdin_open: true
    tty: true
    command: >
      bash -lc 'set -e;
        if command -v apt-get >/dev/null 2>&1; then
          need_pkgs="";
          command -v curl >/dev/null 2>&1 || need_pkgs=1;
          command -v tmux >/dev/null 2>&1 || need_pkgs=1;
          if [ -n "$$need_pkgs" ]; then
            export DEBIAN_FRONTEND=noninteractive;
            apt-get update -qq >/dev/null;
            apt-get install -y -qq curl ca-certificates bzip2 tar tmux libxcb1 >/dev/null;
            rm -rf /var/lib/apt/lists/*;
          fi;
        fi;

        if ! command -v goose >/dev/null 2>&1; then
          arch=$(uname -m);
          case "$$arch" in
            x86_64) goose_url="https://github.com/block/goose/releases/latest/download/goose-x86_64-unknown-linux-gnu.tar.bz2" ;;
            aarch64|arm64) goose_url="https://github.com/block/goose/releases/latest/download/goose-aarch64-unknown-linux-gnu.tar.bz2" ;;
            *) echo "[wad] Unsupported arch for goose: $$arch" >&2; exit 1 ;;
          esac;
          tmp=$(mktemp -d);
          curl -fsSL "$$goose_url" -o "$$tmp/goose.tar.bz2";
          tar -xjf "$$tmp/goose.tar.bz2" -C "$$tmp";
          install -m 0755 "$$tmp/goose" /usr/local/bin/goose;
          rm -rf "$$tmp";
        fi;

        if [ -d /workspace/.wad/goose ]; then
          mkdir -p /root/.config/goose;
          cp -a /workspace/.wad/goose/. /root/.config/goose/ 2>/dev/null || true;
        fi;

        touch /tmp/wad-ready;
        echo "[wad] Ready.";
        exec sleep infinity'

networks:
  default:
    name: wad-${env_name}
EOF

    log_success "Initialized WAD in $repo_root"
    log_info "Edit $WAD_DIR/$WAD_COMPOSE_TEMPLATE to configure your environment"
    log_info "Edit $WAD_DIR/$WAD_CONFIG_FILE for ports and services"

}

cmd_new() {
    local env_arg="$1"; shift || true
    [[ -z "$env_arg" ]] && die "Usage: wad new <env> [prompt...]"
    local prompt="$*"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name worktree_path
    env_name=$(slugify "$env_arg")
    worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"

    if [[ -d "$worktree_path" ]] || git -C "$repo_root" show-ref --verify --quiet "refs/heads/wad/$env_name"; then
        die "Environment already exists: $env_name (use a different name or: wad rm $env_name --force)"
    fi

    log_header "Creating environment: $env_name"

    # Base branch selection precedence:
    # 1) config: worktrees.default_base
    # 2) current branch
    # 3) main/master if present
    # 4) HEAD
    local base_branch
    base_branch=$(get_config "$repo_root" "worktrees.default_base" "")
    [[ -z "$base_branch" ]] && base_branch=$(git -C "$repo_root" symbolic-ref --quiet --short HEAD 2>/dev/null || true)

    if [[ -z "$base_branch" ]]; then
        if git -C "$repo_root" show-ref --verify --quiet refs/heads/main; then
            base_branch="main"
        elif git -C "$repo_root" show-ref --verify --quiet refs/heads/master; then
            base_branch="master"
        else
            base_branch="HEAD"
        fi
    fi

    local env_index
    env_index=$(get_next_env_index "$repo_root")

    log_info "Creating git worktree (branch: wad/$env_name from $base_branch)..."
    git -C "$repo_root" worktree add -b "wad/$env_name" "$worktree_path" "$base_branch"

    log_info "Generating environment config..."
    generate_env_file "$env_name" "$env_index" "$repo_root" > "$worktree_path/.wad-env"

    log_info "Generating docker-compose..."
    generate_compose "$repo_root" "$env_name" "$worktree_path" > "$worktree_path/.wad-compose.yml"

    # Hide wad-generated files inside the worktree from `git status` / diffs.
    ensure_wad_worktree_files_ignored "$worktree_path"

    log_info "Starting containers..."
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" up -d

    wait_for_devcontainer_ready "$worktree_path" "$env_name" 180 || true

    # Start services automatically
    cmd_run "$env_name"

    # Start goose task in background (tmux) only if a prompt was provided.
    if [[ -n "$prompt" ]]; then
        start_goose_task "$repo_root" "$worktree_path" "$env_name" "$prompt"
    fi

    log_success "Environment '$env_name' created"
    [[ -n "$prompt" ]] && log_info "Prompt: $prompt"

    log_info "Ports:"
    (grep "^WAD_PORT_" "$worktree_path/.wad-env" 2>/dev/null || echo "(none)") | sed "s/^/  /"

    log_info "Next:"
    echo "  wad shell $env_name         # Enter the devcontainer"
    if [[ -n "$prompt" ]]; then
        echo "  wad attach $env_name        # Watch goose + logs (tmux; requires a real TTY)"
        echo "  wad status $env_name        # Check goose completion + show JSON result (if any)"
        echo "  wad logs $env_name goose    # Tail goose log (/tmp/goose.log)"
    else
        echo "  wad agent $env_name \"<prompt>\"  # Start goose for this environment"
    fi

    # Machine-parseable last line
    echo "ENV=$env_name"
}

cmd_agent() {
    local env_arg="$1"; shift || true
    [[ -z "$env_arg" ]] && die "Usage: wad agent <env> <prompt...>"

    local prompt="$*"
    [[ -z "$prompt" ]] && die "Usage: wad agent <env> <prompt...>"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name worktree_path
    env_name=$(slugify "$env_arg")
    worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"

    [[ -d "$worktree_path" ]] || die "Not found: $env_name (create it first: wad new $env_name)"

    log_header "Starting goose for environment: $env_name"

    # Ensure containers are up (start if needed)
    if ! is_env_running "$worktree_path" "$env_name"; then
        log_info "Starting containers..."
        docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" up -d
    fi

    wait_for_devcontainer_ready "$worktree_path" "$env_name" 180 || true

    start_goose_task "$repo_root" "$worktree_path" "$env_name" "$prompt"

    log_info "Next:"
    echo "  wad attach $env_name        # Watch goose + logs (tmux; requires a real TTY)"
    echo "  wad status $env_name        # Check goose completion + show JSON result (if any)"
    echo "  wad logs $env_name goose    # Tail goose log (/tmp/goose.log)"
}

cmd_attach() {
    local env_arg="$1"
    [[ -z "$env_arg" ]] && die "Usage: wad attach <env>"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    require_env_running "$worktree_path" "$env_name" || exit 1

    local session_name
    session_name=$(get_agent_config "$repo_root" "session_name" "wad-agent")

    if ! docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc "command -v tmux >/dev/null 2>&1 && tmux has-session -t '$session_name' 2>/dev/null"; then
        die "No tmux session found in container. If you just ran 'wad agent', give it a moment; otherwise run: wad agent $env_name \"<prompt>\""
    fi

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec devcontainer tmux attach -t "${session_name}:agent"
}


cmd_status() {
    local env_arg="$1"
    [[ -z "$env_arg" ]] && die "Usage: wad status <env>"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    require_env_running "$worktree_path" "$env_name" || exit 1

    local done running exit_code

    done=$(docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc "test -f /tmp/wad-goose-done && echo yes || echo no" 2>/dev/null || echo no)
    exit_code=$(docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc "cat /tmp/wad-goose-exit 2>/dev/null || true" 2>/dev/null || true)
    running=$(docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc "pgrep -af 'goose run --no-session --recipe /workspace/.wad/goose/recipes/wad_task.yaml' >/dev/null 2>&1 && echo yes || echo no" 2>/dev/null || echo no)

    echo -e "${BOLD}Status:${NC} $env_name"
    echo "  running: $running"
    echo "  done:    $done"
    [[ -n "$exit_code" ]] && echo "  exit:    $exit_code"

    if [[ "$done" == "yes" ]]; then
        echo ""
        echo -e "${BOLD}Result (if any):${NC}"
        docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -T devcontainer bash -lc '
          if [ ! -s /tmp/wad-goose-out.log ]; then
            echo "(no goose output log found)"
            exit 0
          fi

          python - <<"PY" >/tmp/wad-goose-result.json 2>/dev/null || true
import json

s = open("/tmp/wad-goose-out.log", "r", errors="ignore").read()
for i in range(len(s)-1, -1, -1):
    if s[i] != "}":
        continue
    depth = 0
    for j in range(i, -1, -1):
        c = s[j]
        if c == "}":
            depth += 1
        elif c == "{":
            depth -= 1
            if depth == 0:
                cand = s[j:i+1]
                try:
                    json.loads(cand)
                except Exception:
                    break
                print(cand)
                raise SystemExit(0)
raise SystemExit(2)
PY

          if [ -s /tmp/wad-goose-result.json ]; then
            python -m json.tool /tmp/wad-goose-result.json 2>/dev/null || cat /tmp/wad-goose-result.json
          else
            echo "(no structured JSON result found)"
          fi
        '
    fi
}

cmd_ls() {
    local repo_root
    repo_root=$(check_wad_init)

    echo -e "${BOLD}WAD Environments${NC}"
    echo ""

    local found=0
    for env_dir in "$repo_root/$WAD_WORKTREES_DIR"/*/; do
        [[ -d "$env_dir" ]] || continue
        found=1

        local env_name
        env_name=$(basename "$env_dir")
        local env_file="$env_dir/.wad-env"
        local compose_file="$env_dir/.wad-compose.yml"

        local ports=""
        if [[ -f "$env_file" ]]; then
            ports=$(grep '^WAD_PORT_' "$env_file" 2>/dev/null | sed 's/^WAD_PORT_//' | tr '\n' ' ' | sed 's/[[:space:]]*$//')
        fi

        local status="stopped"
        if [[ -f "$compose_file" ]]; then
            local running
            running=$(docker compose -f "$compose_file" -p "wad-$env_name" ps -q 2>/dev/null | wc -l)
            [[ "$running" -gt 0 ]] && status="${GREEN}running${NC}"
        fi

        local branch
        branch=$(git -C "$env_dir" branch --show-current 2>/dev/null || echo "?")

        printf "  ${BOLD}%-20s${NC} %s  (%s)\n" "$env_name" "${ports:+ports:$ports }$status" "$branch"
    done

    [[ $found -eq 0 ]] && echo "  No environments found. Create one with: wad new <env> [prompt...]"
}

cmd_shell() {
    local env_arg="$1"
    [[ -z "$env_arg" ]] && die "Usage: wad shell <env>"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec devcontainer bash
}

cmd_run() {
    local env_arg="$1"
    [[ -z "$env_arg" ]] && die "Usage: wad run <env>"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    local config="$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"

    # Build command to source env and start services
    local cmd="cd /workspace && "
    cmd+="[[ -f .wad/.env ]] && set -a && source .wad/.env && set +a; "

    # Parse services from config
    local services
    services=$(awk '
        /^services:/ { in_svc = 1; next }
        in_svc && /^[a-zA-Z]/ && !/^[[:space:]]/ { exit }
        in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
            name = $1; gsub(/:/, "", name)
            print name
        }
    ' "$config")

    for svc in $services; do
        local svc_workdir svc_cmd svc_log svc_env

        svc_workdir=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /workdir:/ {
                gsub(/.*workdir:[[:space:]]*/, "");
                gsub(/[[:space:]]*$/, "");
                print; exit
            }
        ' "$config")

        svc_cmd=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /command:/ {
                gsub(/.*command:[[:space:]]*/, "");
                gsub(/[[:space:]]*$/, "");
                print; exit
            }
        ' "$config")

        svc_log=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /log:/ {
                gsub(/.*log:[[:space:]]*/, "");
                gsub(/[[:space:]]*$/, "");
                print; exit
            }
        ' "$config")

        svc_env=$(awk -v svc="$svc" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
                in_env = 0
            }
            in_current && /^[[:space:]]{4}env:/ { in_env = 1; next }
            in_current && in_env && /^[[:space:]]{6}[A-Z_]+:/ {
                key = $1; gsub(/:/, "", key)
                val = $0; gsub(/.*:[[:space:]]*/, "", val)
                gsub(/^\"|\"$/, "", val)
                gsub(/^\x27|\x27$/, "", val)
                print "export " key "=\"" val "\"; "
            }
            in_current && in_env && /^[[:space:]]{4}[a-z]/ { in_env = 0 }
        ' "$config")

        if [[ -n "$svc_cmd" ]]; then
            log_info "Starting $svc..."
            [[ -z "$svc_log" ]] && svc_log="/tmp/${svc}.log"
            local log_redirect=" >> $svc_log 2>&1"
            cmd+="$svc_env cd ${svc_workdir:-/workspace} && $svc_cmd$log_redirect & "
        fi
    done

    cmd+="echo 'Services started'; sleep infinity"

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" exec -d devcontainer bash -c "$cmd"

    log_success "Services started"
    log_info "View logs: wad logs $env_name <service>"
}

cmd_logs() {
    local env_arg="$1"; shift || true
    [[ -z "$env_arg" ]] && die "Usage: wad logs <env> [svc|goose] [--tail N] [--follow]"

    local service=""
    local tail_lines="${WAD_LOGS_TAIL:-200}"
    local follow=0
    local timeout_dur="${WAD_LOGS_TIMEOUT:-5s}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tail)
                tail_lines="${2:-}"; shift 2 || true
                ;;
            --tail=*)
                tail_lines="${1#*=}"; shift
                ;;
            -n)
                tail_lines="${2:-}"; shift 2 || true
                ;;
            -f|--follow)
                follow=1; shift
                ;;
            --timeout)
                timeout_dur="${2:-}"; shift 2 || true
                ;;
            --timeout=*)
                timeout_dur="${1#*=}"; shift
                ;;
            -h|--help)
                cat << EOF
Usage: wad logs <env> [svc|goose] [--tail N] [--follow]

Defaults:
  --tail ${WAD_LOGS_TAIL:-200}
  (no follow; prints and exits)

Notes:
  - Without a service, prints docker compose logs for the environment.
  - With a service name, prints the last N lines of the configured service log file inside the devcontainer.
  - With 'goose', prints the last N lines of /tmp/goose.log inside the devcontainer.
EOF
                return 0
                ;;
            *)
                if [[ -z "$service" ]]; then
                    service="$1"; shift
                else
                    die "Unknown arg for 'wad logs': $1"
                fi
                ;;
        esac
    done

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    local compose_file="$worktree_path/.wad-compose.yml"
    [[ -f "$compose_file" ]] || die "Missing compose file for env: $env_name ($compose_file)"

    # Compose logs (fast, no TTY). Default behavior is to print and exit.
    if [[ -z "$service" ]]; then
        if [[ "$follow" -eq 1 ]]; then
            docker compose -f "$compose_file" -p "wad-$env_name" logs --no-color --tail "$tail_lines" -f
        else
            run_with_timeout "$timeout_dur" docker compose -f "$compose_file" -p "wad-$env_name" logs --no-color --tail "$tail_lines" || true
        fi
        return 0
    fi

    # If the container isn't running, we can't `exec` to read log files.
    # Fall back to compose logs so callers still get something useful.
    if ! is_env_running "$worktree_path" "$env_name"; then
        log_warn "Environment '$env_name' is not running; cannot read in-container log files. Showing compose logs instead."
        run_with_timeout "$timeout_dur" docker compose -f "$compose_file" -p "wad-$env_name" logs --no-color --tail "$tail_lines" || true
        return 0
    fi

    local file_path=""
    if [[ "$service" == "goose" ]]; then
        file_path="/tmp/goose.log"
    else
        local config="$repo_root/$WAD_DIR/$WAD_CONFIG_FILE"
        local log_file
        log_file=$(awk -v svc="$service" '
            /^services:/ { in_svc = 1; next }
            in_svc && /^[[:space:]]{2}[a-zA-Z_-]+:/ {
                current = $1; gsub(/:/, "", current)
                in_current = (current == svc)
            }
            in_current && /log:/ {
                gsub(/.*log:[[:space:]]*/, "");
                gsub(/[[:space:]]*$/, "");
                print; exit
            }
        ' "$config")

        [[ -z "$log_file" ]] && log_file="/tmp/${service}.log"
        file_path="$log_file"
    fi

    local tail_cmd
    if [[ "$follow" -eq 1 ]]; then
        tail_cmd="tail -n $tail_lines -F '$file_path'"
    else
        tail_cmd="tail -n $tail_lines '$file_path'"
    fi

    # Read the log file from inside the devcontainer.
    # - Use -T (no TTY) so this works in MCP/CI contexts.
    # - Do not wait for /tmp/wad-ready; logs should be best-effort.
    # - Wrap in a timeout when not following.
    local exec_cmd=(docker compose -f "$compose_file" -p "wad-$env_name" exec -T devcontainer bash -lc)

    local shell_snippet
    shell_snippet="if [ -f '$file_path' ]; then $tail_cmd; else echo '(no $file_path found)'; fi"

    if [[ "$follow" -eq 1 ]]; then
        "${exec_cmd[@]}" "$shell_snippet" || true
    else
        run_with_timeout "$timeout_dur" "${exec_cmd[@]}" "$shell_snippet" || {
            log_warn "Failed to exec into devcontainer (maybe still starting). Showing compose logs instead."
            run_with_timeout "$timeout_dur" docker compose -f "$compose_file" -p "wad-$env_name" logs --no-color --tail "$tail_lines" || true
        }
    fi
}

cmd_mcp() {
    # Start the local stdio MCP server that exposes `wad` operations.
    # Intended usage (for MCP-capable clients):
    #   command: wad
    #   args: ["mcp"]
    #
    # By default the MCP server runs `wad` in the current working directory.
    # You can override the project root with:
    #   wad mcp --project-root /path/to/repo

    local project_root="" wad_bin="" python_bin="python3" no_install=0
    local python_arg_set=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project-root)
                project_root="${2:-}"; shift 2 || true
                ;;
            --wad-bin)
                wad_bin="${2:-}"; shift 2 || true
                ;;
            --python)
                python_bin="${2:-}"; python_arg_set=1; shift 2 || true
                ;;
            --no-install)
                no_install=1; shift
                ;;
            -h|--help)
                cat << EOF
Usage: wad mcp [--project-root PATH] [--wad-bin PATH] [--python PYTHON] [--no-install]

Starts the WAD MCP server over stdio.

Options:
  --project-root PATH   Directory to run wad in (sets WAD_PROJECT_ROOT)
  --wad-bin PATH        Path to wad executable for the server (sets WAD_BIN)
  --python PYTHON       Python executable to use (default: python3)
  --no-install          Do not auto-install Python dependency (fastmcp)
EOF
                return 0
                ;;
            *)
                die "Unknown arg for 'wad mcp': $1"
                ;;
        esac
    done

    # Prefer an installed entrypoint if it exists.
    if command -v wad-mcp-server >/dev/null 2>&1; then
        [[ -n "$project_root" ]] && export WAD_PROJECT_ROOT="$project_root"
        [[ -n "$wad_bin" ]] && export WAD_BIN="$wad_bin"
        exec wad-mcp-server
    fi

    # Otherwise, run the vendored server code installed by install.sh.
    local mcp_home
    mcp_home="${WAD_MCP_SERVER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/wad-mcp-server}"

    if [[ ! -d "$mcp_home/wad_mcp_server" ]] || [[ ! -f "$mcp_home/wad_mcp_server/server.py" ]]; then
        die "MCP server code not found. Re-run install.sh or set WAD_MCP_SERVER_DIR (expected: $mcp_home/wad_mcp_server/server.py)"
    fi

    # If install.sh created a dedicated venv for the MCP server, prefer it by default.
    # This avoids issues with system-managed Python environments (PEP 668) and missing user-site paths.
    local venv_python="$mcp_home/venv/bin/python"
    if [[ "$python_arg_set" -eq 0 ]] && [[ -x "$venv_python" ]]; then
        python_bin="$venv_python"
    fi

    command -v "$python_bin" >/dev/null 2>&1 || die "Python not found: $python_bin"

    # Ensure FastMCP dependency is present.
    if ! "$python_bin" -c "import fastmcp" >/dev/null 2>&1; then
        if [[ "$no_install" -eq 1 ]]; then
            die "Python dependency 'fastmcp' is not installed. Re-run install.sh (it installs into a venv), or install manually: $python_bin -m pip install 'fastmcp>=2.14.0'"
        fi

        # If we're using the vendored venv, install into the venv. Otherwise fallback to user scope.
        if [[ "$python_bin" == "$venv_python" ]]; then
            log_info "Installing Python dependency: fastmcp (venv scope)"
            "$python_bin" -m pip --version >/dev/null 2>&1 || "$python_bin" -m ensurepip --upgrade >/dev/null 2>&1 || true
            "$python_bin" -m pip install "fastmcp>=2.14.0" || die "Failed to install fastmcp into MCP venv: $mcp_home/venv"
        else
            log_info "Installing Python dependency: fastmcp (user scope)"
            "$python_bin" -m pip install --user "fastmcp>=2.14.0" || die "Failed to install fastmcp. Ensure pip is available for $python_bin"
        fi
    fi

    [[ -n "$project_root" ]] && export WAD_PROJECT_ROOT="$project_root"
    [[ -n "$wad_bin" ]] && export WAD_BIN="$wad_bin"

    # Add vendored code to module path and run the server.
    PYTHONPATH="$mcp_home${PYTHONPATH:+:$PYTHONPATH}" exec "$python_bin" -m wad_mcp_server.server
}


cmd_start() {
    local env_arg="$1"
    [[ -z "$env_arg" ]] && die "Usage: wad start <env>"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    load_env_config "$repo_root" "$env_name"
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" up -d
    log_success "Started"
}

cmd_stop() {
    local env_arg="$1"
    [[ -z "$env_arg" ]] && die "Usage: wad stop <env>"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" stop
    log_success "Stopped"
}

cmd_rm() {
    local env_arg="$1" force="${2:-}"
    [[ -z "$env_arg" ]] && die "Usage: wad rm <env> [--force]"

    local repo_root
    repo_root=$(check_wad_init)

    local env_name
    env_name=$(slugify "$env_arg")

    local worktree_path="$repo_root/$WAD_WORKTREES_DIR/$env_name"
    [[ -d "$worktree_path" ]] || die "Not found: $env_name"

    if [[ "$force" != "--force" ]]; then
        read -p "Remove '$env_name'? [y/N] " -n 1 -r; echo
        [[ $REPLY =~ ^[Yy]$ ]] || exit 0
    fi

    log_info "Removing containers..."
    docker compose -f "$worktree_path/.wad-compose.yml" -p "wad-$env_name" down -v 2>/dev/null || true

    log_info "Removing worktree..."
    if ! git -C "$repo_root" worktree remove "$worktree_path" --force 2>/dev/null; then
        log_warn "Worktree removal failed; deleting uid=0 (root-owned) paths and retrying..."
        docker run --rm -v "$worktree_path:/workspace" alpine:3.19 sh -c '
          set -e
          find /workspace -mindepth 1 -uid 0 -exec rm -rf -- {} + 2>/dev/null || true
        ' || true

        git -C "$repo_root" worktree remove "$worktree_path" --force 2>/dev/null || rm -rf "$worktree_path"
    fi

    git -C "$repo_root" branch -D "wad/$env_name" 2>/dev/null || true

    log_success "Removed"
}

cmd_help() {
    cat << EOF
${BOLD}wad${NC} v$WAD_VERSION - Worktree Agent Devcontainers

${BOLD}PRIMARY WORKFLOW${NC}
  wad init
  # edit .wad/compose.yml and .wad/config.yml
  wad new <env> [prompt...]   Create env, start containers+services, optionally start goose
  wad agent <env> <prompt...> Start goose for an existing environment
  wad attach <env>            Attach to the tmux session to watch progress

${BOLD}COMMANDS${NC}
  init                     Initialize wad in current repo
  new <env> [prompt...]     Create a new environment
  agent <env> <prompt...>   Start goose in an existing environment
  attach <env>             Attach to goose tmux session inside the devcontainer
  status <env>             Show goose task status and (if available) the structured result JSON
  ls                       List environments

  start <env>              Start containers
  stop <env>               Stop containers
  rm <env> [--force]       Remove environment

  shell <env>              Enter container shell
  run <env>                Start services (from config.yml)
  logs <env> [svc|goose] [--tail N] [--follow]
                           View logs (default: prints and exits; use --follow to stream)

  mcp                      Start the local stdio MCP server that exposes wad operations

${BOLD}EXAMPLE${NC}
  wad init
  wad new feature-x
  wad agent feature-x "add a healthcheck endpoint and tests"
  wad attach feature-x
EOF
}

# Main
case "${1:-help}" in
    init)    cmd_init "${@:2}" ;;
    new)     cmd_new "${@:2}" ;;
    agent)   cmd_agent "${@:2}" ;;
    attach)  cmd_attach "${@:2}" ;;
    status)  cmd_status "${@:2}" ;;
    ls)      cmd_ls ;;
    start)   cmd_start "${@:2}" ;;
    stop)    cmd_stop "${@:2}" ;;
    rm)      cmd_rm "${@:2}" ;;
    shell)   cmd_shell "${@:2}" ;;
    run)     cmd_run "${@:2}" ;;
    logs)    cmd_logs "${@:2}" ;;
    mcp)     cmd_mcp "${@:2}" ;;
    help|--help|-h) cmd_help ;;
    version|--version|-v) echo "wad $WAD_VERSION" ;;
    *)       die "Unknown: $1" ;;
esac
